<!doctype html>
 
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    
    <title>Symbol Typing Quest</title>
    <meta name="description" content="This is a typing game using the Symbol blockchain.<br>

MusMus https://musmus.main.jp<br>" />
    
    <style>*, *:before, *:after {
  box-sizing: border-box; 
}
html {
  font-size: 13px;
}
body {
  font-family: Avenir, "Open Sans", "Helvetica Neue", Helvetica, Arial, Verdana, Roboto, "游ゴシック", "Yu Gothic", "游ゴシック体", "YuGothic", "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro", "Meiryo UI", "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif;
  color: #444;
  background-color: hsl(0, 0%, 96%);
}
h1 {
  font-size: 1.8rem;
}

</style>
  </head>
  <body>
    <h1>Symbol Typing Quest</h1>
    <p>This is a typing game using the Symbol blockchain.<br>

MusMus https://musmus.main.jp<br></p>
    

    <script src="https://cdn.jsdelivr.net/gh/phinajs/phina.js@v0.2.0/build/phina.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.js" defer></script>
    <script src="https://xembook.github.io/nem2-browserify/symbol-sdk-1.0.3.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@8"></script>
    <script src="https://cdn.jsdelivr.net/npm/promise-polyfill"></script>
    <script>/*
 * Runstant
 * 思いたったらすぐ開発. プログラミングに革命を...
 */

phina.globalize();

var SCREEN_WIDTH    = 649;  // default 640
var SCREEN_HEIGHT   = 960;  // default 960
var PIECE_SIZE      = 80;
var PIECE_SIZE_HALF = PIECE_SIZE/2;
var MARGIN          = 160;
var GAME_MODE       = {
  nomal     : 1,
  hard      : 2
};

// アセット
var ASSETS = {
  // 画像
  image: {
    'title_bg': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/title-back.png',
    'game_bg':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/game_background01.png',
    'result_bg': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/result_bg2.png',
    'gameover_bg': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/gamover_bg2.png',
    'boss': 'https://github.com/kurikou02/symbol_game_asset/blob/main/test/Hatchet_Avatar_CircleCrop_200px.png?raw=true',
    'Hatchet': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/boss_Hatchet_Avatar.png',
    'Jaguar': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/boss_Jaguar_Avatar.png',
    'Gimre': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/boss_Gimre_Avatar.png',
    'bullet': 'https://github.com/kurikou02/symbol_game_asset/blob/main/test/Hatchet_Avatar_CircleCrop_200px.png?raw=true',
    'shuriken': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/shuriken02.png',
    'ono': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/ono.png',
    'beam': 'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/beam.png',
    'Bomb':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/image/Bomb.png',
  },
  sound:{
    // 入力文字OK時
    'ok':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/shot01.mp3',
    // 入力文字NG時
    'ng':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/cncl01.mp3',
    // 敵味方へのダメージ効果音
    'damage':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/boss_damage.mp3',
    // ボス撃破時
    'ko':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/boss_ko.mp3',
    // ゲーム開始音
    'system01':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/system01.mp3',
    // 1単語クリア
    'word_clear':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/word_clear.mp3',
    // 時間切れ
    'timeout':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/timeout.mp3',
    // ゲームオーバー
    'game_clear':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/game_clear.mp3',
    // ゲームクリア
    'game_over':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/game_over.mp3',
    // ボム発動
    'bomb_sound':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/bomb.mp3',
    // 戦闘BGM
    'bgm':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/sound/Pirate_bgm.mp3',
  },
  font:{
    'Rajdhani-bold':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/font/Rajdhani/Rajdhani-Bold.ttf',
    'Rajdhani-light':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/font/Rajdhani/Rajdhani-Light.ttf',
    'Rajdhani-medium':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/font/Rajdhani/Rajdhani-Medium.ttf',
    'Rajdhani':'https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/font/Rajdhani/Rajdhani-Regular.ttf',
  },
};

// ゲーム設定保持
var SETTINGS = {
  mode: 1,
  stage: 1,
  player_address: '',
  bomb_mosaic: 0,
  bomb_use_count: 0,
  reward_mosaic: 0,
  isDemo: false,
  isReplay: false,
}

// 単語リストのCSV
var WORDS_LIST_EASY = [];
var WORDS_LIST_HARD = [];

// スコア保持
var clear_time = 0;
var total_score = 0;
var total_miss = 0;

/*
 * Symbolクラス
 */
phina.define("MySymbolClass", {
  // 初期化
  init: function() {
    xym = require("/node_modules/symbol-sdk");
    const node = 'http://sym-test-01.opening-line.jp:3000';
    const repo = new xym.RepositoryFactoryHttp(node,xym.NetworkType.TEST_NET);
    const restrictionRepo = repo.createRestrictionAccountRepository();
    const transactionHttp = repo.createTransactionRepository();
    const accountHttp = repo.createAccountRepository();
    const epochAdjustment = 1637848847;
    
    
    // 送金元送金元プライベートキー(ゲーム用テストアカウントで固定)
    const privateKey = '83192D535D0A98001AE352DB2E73534DF653B501BA2BF2F3B07EAB2DF89245CB';
    const publicKey = '983FC65B0F29540E77847ADD6AF22C16DE98A2AEFC20F1C7D23867B17CEF3324';
    const fromAddress = 'TDEAUFR5ED25QUUGPO7M6SXVSD6OSUEDFPAAL5A';
    
    // デモユーザのアドレス
    const demoUserAddress = 'TBS6OAC3ZM66ZVSXNURUQGOYT6AVA4MFXUVS3EI';
    
    // モザイクID
    const bombMosaicId = '0A88CF92907753CC';
    const rewadMosaicId = '1B5DB759234E38F2';
    const xymMosaicId = new xym.MosaicId('46BE9BC0626F9B1A');
    const xymDivisibility = 6;

    this.xym = xym;
    this.accountHttp = accountHttp;
    this.transactionHttp =  transactionHttp; 
    this.epochAdjustment = epochAdjustment;
    this.privateKey = privateKey;
    this.publicKey = publicKey;
    this.fromAddress = fromAddress;

    this.demoUserAddress =  demoUserAddress;
    this.bombMosaicId = bombMosaicId;
    this.rewadMosaicId = rewadMosaicId;
  },
  
  // アドレス取得
  getAddress: function(rawAddress){
    return this.xym.Address.createFromRawAddress(rawAddress);
  },

  // 回収可能モザイクの生成
  createRevokableMosaic: function() {
    console.log('---- createRevokableMosaic -----');
    //
    // block1
    //
    const networkType = this.xym.NetworkType.TEST_NET;
    const account = this.xym.Account.createFromPrivateKey(this.privateKey, networkType);
    // モザイク設定
    const isSupplyMutable = true;
    const isTransferable = false;  // 転送不可にする
    const isRestrictable = true;
    const isRevokable = true;      // 回収可能フラグ
    const nonce = this.xym.MosaicNonce.createRandom();

    const mosaicDefinitionTransaction = this.xym.MosaicDefinitionTransaction.create(
      this.xym.Deadline.create(this.epochAdjustment),
      nonce,
      this.xym.MosaicId.createFromNonce(nonce, account.address),
      this.xym.MosaicFlags.create(isSupplyMutable, isTransferable, isRestrictable, isRevokable),
      0,  // divisibility(可分性)
      this.xym.UInt64.fromUint(500000), // duration(期間)
      networkType,
    );
    //
    // block2
    //
    const delta = 1000;
    
    const mosaicSupplyChangeTransaction = this.xym.MosaicSupplyChangeTransaction.create(
      this.xym.Deadline.create(epochAdjustment),
      mosaicDefinitionTransaction.mosaicId,
      this.xym.MosaicSupplyChangeAction.Increase,
      this.xym.UInt64.fromUint(delta * Math.pow(10, 0)),
      networkType,
    );
    //
    // block3
    //
    const aggregateTransaction = this.xym.AggregateTransaction.createComplete(
      this.xym.Deadline.create(epochAdjustment),
      [
        mosaicDefinitionTransaction.toAggregate(account.publicAccount),
        mosaicSupplyChangeTransaction.toAggregate(account.publicAccount),
      ],
      networkType,
      [],
      this.xym.UInt64.fromUint(2000000),
    );
    // replace with meta.networkGenerationHash (nodeUrl + '/node/info')
    const networkGenerationHash =
      '7FCCD304802016BEBBCD342A332F91FF1F3BB5E902988B352697BE245F48E836';
    const signedTransaction = account.sign(
      aggregateTransaction,
      networkGenerationHash,
    );
    // replace with node endpoint
    const nodeUrl = 'https://sym-test-06.opening-line.jp:3001';
    const repositoryFactory = new this.xym.RepositoryFactoryHttp(nodeUrl, networkType);
    const transactionHttp = repositoryFactory.createTransactionRepository();
    
    transactionHttp.announce(signedTransaction).subscribe(
      (x) => console.log(x),
      (err) => console.error(err),
    );
  },
  
  // モザイクの回収！
  mosaicRevokable: function(targetAddress){
    
    console.log('---- mosaic Revokable -----');
    const networkType = this.xym.NetworkType.TEST_NET;
    const account = this.xym.Account.createFromPrivateKey(this.privateKey, networkType);
    const amount = 1;
    const mosaicSupplyRevocationTransaction = this.xym.MosaicSupplyRevocationTransaction.create(
        this.xym.Deadline.create(this.epochAdjustment),
        this.xym.Address.createFromRawAddress(targetAddress),
        new this.xym.Mosaic(new this.xym.MosaicId(this.bombMosaicId), this.xym.UInt64.fromUint(amount)),
        networkType,
        this.xym.UInt64.fromUint(1000000)
    );
    
    const aggregateTransaction = this.xym.AggregateTransaction.createComplete(
      this.xym.Deadline.create(this.epochAdjustment),
      [
        mosaicSupplyRevocationTransaction.toAggregate(account.publicAccount)
      ],
      networkType,
      [],
      this.xym.UInt64.fromUint(2000000));
      
    // replace with meta.networkGenerationHash (nodeUrl + '/node/info')
    const networkGenerationHash =
      '7FCCD304802016BEBBCD342A332F91FF1F3BB5E902988B352697BE245F48E836';
    const signedTransaction = account.sign(
      aggregateTransaction,
      networkGenerationHash);
    
    // トランザクション発行
    this.announce(signedTransaction);
    
  },
  
  // XYM送金！
  sendXym: function( trgetAddress, amount, msg ){

    console.log('---- send Xym -----');
    
    // トランザクション作成
    const account = this.xym.Account.createFromPrivateKey(this.privateKey, this.xym.NetworkType.TEST_NET);
    const transferTransaction = this.xym.TransferTransaction.create(
      this.xym.Deadline.create(this.epochAdjustment),
      this.xym.Address.createFromRawAddress(trgetAddress), 
      [new this.xym.Mosaic (new this.xym.MosaicId('3A8416DB2D53B6C8'),this.xym.UInt64.fromUint(amount * Math.pow(10, 6)))],
      this.xym.PlainMessage.create(msg),
      this.xym.NetworkType.TEST_NET,
      this.xym.UInt64.fromUint(100000)
    );
    // 署名
    const networkGenerationHash =
      '7FCCD304802016BEBBCD342A332F91FF1F3BB5E902988B352697BE245F48E836';
    const signedTransaction = account.sign(
      transferTransaction,
      networkGenerationHash);
    
    // 発行
    this.announce(signedTransaction);
    
  },
  
  // クリア証明トークンと賞金の送付！！
  sendClearReward: function( trgetAddress, msg ){

    console.log('---- send Xym and ClearReward -----');
    
    // トランザクション作成
    const account = this.xym.Account.createFromPrivateKey(this.privateKey, this.xym.NetworkType.TEST_NET);
    const transferTransaction = this.xym.TransferTransaction.create(
      this.xym.Deadline.create(this.epochAdjustment),
      this.xym.Address.createFromRawAddress(trgetAddress), 
      [
        new this.xym.Mosaic (
          new this.xym.MosaicId('3A8416DB2D53B6C8'),
          this.xym.UInt64.fromUint(10 * Math.pow(10, 6 ))
        ),
        new this.xym.Mosaic (
          new this.xym.MosaicId(this.rewadMosaicId),
          this.xym.UInt64.fromUint(1)
        ),
       ],
      this.xym.PlainMessage.create(msg),
      this.xym.NetworkType.TEST_NET,
      this.xym.UInt64.fromUint(100000)
    );
    // 署名
    const networkGenerationHash =
      '7FCCD304802016BEBBCD342A332F91FF1F3BB5E902988B352697BE245F48E836';
    const signedTransaction = account.sign(
      transferTransaction,
      networkGenerationHash);
    
    // 発行
    this.announce(signedTransaction);
  },
  
  
  // BOMBモザイク送信！
  sendBombMosaic: function( trgetAddress, amount, msg ){

    console.log('---- send Bomb Mosaic -----');
    // トランザクション作成
    const account = this.xym.Account.createFromPrivateKey(this.privateKey, this.xym.NetworkType.TEST_NET);
    const transferTransaction = this.xym.TransferTransaction.create(
      this.xym.Deadline.create(this.epochAdjustment),
      this.xym.Address.createFromRawAddress(trgetAddress), 
      [new this.xym.Mosaic (new this.xym.MosaicId(this.bombMosaicId),this.xym.UInt64.fromUint(amount))],
      this.xym.PlainMessage.create(msg),
      this.xym.NetworkType.TEST_NET,
      this.xym.UInt64.fromUint(100000)
    );
    // 署名
    const networkGenerationHash =
      '7FCCD304802016BEBBCD342A332F91FF1F3BB5E902988B352697BE245F48E836';
    const signedTransaction = account.sign(
      transferTransaction,
      networkGenerationHash);
    
    // 発行
    this.announce(signedTransaction);
  },
  
  // トランザクションの発行
  announce: function( signedTransaction ){
    
    const nodeUrl = 'https://sym-test-06.opening-line.jp:3001';
    const repositoryFactory = new this.xym.RepositoryFactoryHttp(nodeUrl, this.xym.NetworkType.TEST_NET);
    const transactionHttp = repositoryFactory.createTransactionRepository();
    
    transactionHttp.announce(signedTransaction).subscribe(
      (x) => console.log(x),
      (err) => console.error(err));
  },
  
});

/*
 * タイトルシーン
 */
phina.define('TitleScene', {
  superClass: 'DisplayScene',
  /**
   * @constructor
   */
  init: function() {
    this.superInit();
    
    // 共通パラメータ初期化
    SETTINGS.stage = 1;
    SETTINGS.bomb_mosaic = 0;
    SETTINGS.bomb_use_count = 0;
    total_score = 0;
    total_miss = 0;
    clear_time = 0;

    // symbol クラス生成
    var symbol = MySymbolClass();
    this.symbol = symbol;
    
    // 背景グループ
    var bgGroup = DisplayElement().addChildTo(this);
    this.bgGroup = bgGroup;

    // 背景画像追加
    (2).times(function(i) {
      Sprite('title_bg').addChildTo(bgGroup)
                  .setPosition(this.gridX.center(), this.gridY.center())
                  .setSize(SCREEN_WIDTH, SCREEN_HEIGHT)
    }, this);
    
    // ラベル定義
    this.fromJSON({
      children: {
        // タイトル
        titleLabel: {
          className: 'Label',
          text: 'Symbol Typing Quest',
          fontSize: 50,
          x: this.gridX.center(),
          y: this.gridY.span(2.5),
          fontFamily:'Rajdhani-bold',
          fill: 'white',
          align: 'center', 
        },
        // ゲーム説明
        descriptionLabel: {
          className: 'Label',
          text: 'This is a typing game using the Symbol blockchain.\n' + 
                'Please type in the address of the testnet.\n' +
                '\nDon\'t worry If you don\'t have an Symbol address, \n You can play in trial mode!',
          fontSize: 28,
          x: this.gridX.center(),
          y: this.gridY.span(5),
          fontFamily:'Rajdhani',
          fill: 'white',
          align: 'center', 
        },
        // 入力フォームの説明
        inputLabel: {
          className: 'Label',
          text: 'Please Input Your Symbol Address(Only TestNet)',
          fontSize: 24,
          x: this.gridX.center(),
          y: this.gridY.span(8.2),
          fontFamily:'Rajdhani',
          fill: 'white',
          align: 'center', 
        },
        // ユーザ向けメッセージ
        messageLabel: {
          className: 'Label',
          text: '',
          fontSize: 20,
          x: this.gridX.center(),
          y: this.gridY.span(9.5),
          align: 'center', 
          fontFamily:'Rajdhani',
          fill: 'white',
        },
      },
    });

    // Symbolアドレス入力フォームセット
    this.input = this.createInput(SCREEN_WIDTH*0.6,this.gridX.span(2),this.gridY.span(7), '');
    
    // アドレス読み取りボタン
    var GetAddressButton = Button({
      width: 80,             // 横サイズ
      height:40,            // 縦サイズ
      text: "Go", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: '#170a29',    // ボタン色
      stroke: '#977bff',     // 枠色
      strokeWidth: 5,     // 枠太さ
    }).addChildTo(this).setPosition(this.gridX.span(13.2), this.gridY.span(7.5));

    // ノーマルモードプレイボタン
    var PlayNomalButton = Button({
      width: 400,             // 横サイズ
      height:60,            // 縦サイズ
      text: "Difficulty: Normal", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: '#170a29',    // ボタン色
      stroke: '#a9a9a9',     // 枠色
      strokeWidth: 5,     // 枠太さ
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(11));
    //PlayNomalButton.hide(); // 初期状態は非表示
    this.PlayNomalButton = PlayNomalButton;
    
    // ハードモードプレイボタン
    var PlayHardButton = Button({
      width: 400,             // 横サイズ
      height:60,            // 縦サイズ
      text: "Difficulty: Hard", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: '#170a29',    // ボタン色
      stroke: '#a9a9a9',     // 枠色
      strokeWidth: 5,     // 枠太さ
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(12.5));
    //PlayHardButton.hide(); // 初期状態は非表示
    this.PlayHardButton  = PlayHardButton;
    
    // デモプレイボタン
    var DemoModeButton = Button({
      width: 400,             // 横サイズ
      height:60,            // 縦サイズ
      text: "Trial Mode", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: '#170a29',    // ボタン色
      stroke: '#977bff',     // 枠色
      strokeWidth: 5,     // 枠太さ
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(14));
    this.DemoModeButton = DemoModeButton;
    
    // TEST用ボタン
    var testButton = Button({
      width: 400,             // 横サイズ
      height:60,            // 縦サイズ
      text: "TEST", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: 'skyblue',    // ボタン色
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(1));
    this.testButton = testButton;
    this.testButton.hide();
    
    // ワードリスト読み込み
    // 汚い書き方だけどグローバル変数で受ける
    this.read_csv('https://cdn.jsdelivr.net/gh/kurikou02/symbol_game_asset@main/data/SymbolWords.csv');
    
    
    // this参照を保持
    var self = this;
    
    // リプレイ判定
    // リプレイ時はアドレス入力と認証をスキップ
    if( SETTINGS.isReplay ){
      
      // リプレイフラグ落とす
      SETTINGS.isReplay = false;
              
      // デモモードでリプレイの場合
      if( SETTINGS.isDemo ){
        //デモ設定反映
        SETTINGS.player_address = symbol.demoUserAddress;
      }else{
      
        // アドレス情報問い合わせ
        address = symbol.getAddress(SETTINGS.player_address);
        symbol.accountHttp.getAccountInfo(address).subscribe(
          (accountInfo) => {
            // 成功時処理
            resolv(accountInfo, address, self);
          },
          (err) => {
            console.error(err)
            reject(self);
          },
        );
      }
      
    }else{
      // 違う場合はプレイヤアドレスもデモフラグも初期化
      SETTINGS.player_address = '';
      SETTINGS.isDemo = false;
      SETTINGS.mode =  GAME_MODE.nomal;
    }
      
    
    // ++++++++++++++++++++++++++++
    // イベント処理
    // ++++++++++++++++++++++++++++
    // Symbolアドレスチェック成功時処理  
    var resolv = this.onSymbolAddressSuccess; 
    var reject = this.onSymbolAddressError; 

    // Symbolアドレス取得ボタン押下時
    GetAddressButton.onclick = function(){
      
      // 空なら何もしない
      if( !self.input.value ){
        return;
      }
      
      // アドレス情報問い合わせ
      address = symbol.getAddress(self.input.value);
      symbol.accountHttp.getAccountInfo(address).subscribe(
        (accountInfo) => {
          // 成功時処理
          resolv(accountInfo, address, self);
        },
        (err) => {
          console.error(err)
          reject(self);
        },
      );
    }
    
    // ノーマルモードボタン押下時
    PlayNomalButton.onclick = function(){
      
      if( !SETTINGS.player_address ) return;
      if( SETTINGS.isDemo ) return;
      
      SoundManager.play('system01');
      SETTINGS.isDemo = false;
      // 難易度難易度ノーマル設定
      SETTINGS.mode = GAME_MODE.nomal;
      // 入力フォーム削除してゲーム画面へ
      self.input.remove();
      self.exit();
    }
    
    // ハードモードボタン押下時
    PlayHardButton.onclick = function(){
      
      if( !SETTINGS.player_address ) return;
      if( SETTINGS.isDemo ) return;
      
        SoundManager.play('system01');
        SETTINGS.isDemo = false;
            
         // 難易度ハード設定
        SETTINGS.mode = GAME_MODE.hard;
        // 入力フォーム削除してゲーム画面へ
        self.input.remove();
        self.exit();
    }
    
    // デモモードボタン押下時
    DemoModeButton.onclick = function(){
      
      if( SETTINGS.isDemo == false && SETTINGS.player_address ) return;
        
      SoundManager.play('system01');
      
      // 入力フォーム削除
      self.input.remove();
      //デモ設定反映
      SETTINGS.player_address = symbol.demoUserAddress;
      SETTINGS.isDemo = true;
      self.exit();
    }
    
    // テストボタン押下時
    testButton.onclick = function(){
      //console.log('回収モザイク生成！');
      //symbol.createRevokableMosaic();
      
      //console.log('モザイク回収！');
      //symbol.mosaicRevokable(symbol.demoUserAddress);
    }
    
  },
  
  // Symbolアドレス認証成功
  onSymbolAddressSuccess: function(accountInfo, address, self){
    console.log('get addressInfo resolved');
    console.log(accountInfo);
    
    // 初期化
    SETTINGS.bomb_mosaic = 0;
    SETTINGS.reward_mosaic = 0;
    
    // モザイクチェック
    var bomb = 0;
    var reward= 0;
    
    for(i = 0 ; i < accountInfo.mosaics.length ; i++){

        var id = accountInfo.mosaics[i].id.toHex();
        var amount = accountInfo.mosaics[i].amount.compact();
        
        // ボムモザイク
        if( id == self.symbol.bombMosaicId ){
          console.log('Bomb Mosaic count -> ' + amount );
          bomb = amount;
          SETTINGS.bomb_mosaic = amount;
          break;
        }
    }
    
    // プレイヤー情報保持
    SETTINGS.player_address = accountInfo.address.address;

    // ラベル更新
    self.messageLabel.text = 'Symbol Address Check OK\n' + 
                             '[ ' + SETTINGS.player_address + ' ]\n' + 
                             'BOMB Mosaic count：' + bomb;
    // ボタン更新
    self.PlayNomalButton.stroke = '#977bff';
    self.PlayHardButton.stroke = '#977bff';
    self.DemoModeButton.stroke = '#a9a9a9';
    
    // 
    SETTINGS.isDemo = false;
  },

  // Symbolアドレス認証失敗
  onSymbolAddressError: function(self){
    console.log('アドレスチェックNG!！');
    // ラベル表示
    self.messageLabel.text = 'Address check failed.\n' +
                             'Please make sure that the address you entered is correct.';

    SETTINGS.player_address = '';
    
    // ボタン更新
    self.PlayNomalButton.stroke = '#a9a9a9';
    self.PlayHardButton.stroke = '#a9a9a9';
  },

  // アドレス入力フォーム生成
  createInput: function(w, l, t, v){
    // DOM操作
    let dom = this.baseDom;
    // 回答用input要素生成
    let input = document.createElement('input');
    // input要素にtext属性付与
    input.getAttribute('text');
    // input要素にtext属性付与
    input.getAttribute('value');
    // スタイルを設定
    let s = input.style;
    s.width = `${w}px`;
    s.height = '45px';
    s.position = 'absolute';
    s.margin = '8px';
    s.left = l + 'px';
    s.top = t + 'px';
    s.fontSize = '32px';
    s.backgroundColor = 'while';
    s.color = 'Gray';
    s.border = '2px solid Gray';
    dom.appendChild(input);
    s.overflowY = 'hidden';
    s.value = v;
    s.visibility = 'hideen';
    // 参照のために返す
    return input;
  },
  
  // CSV読み込み
  read_csv: function(dataPath) {
    const request = new XMLHttpRequest(); // HTTPでファイルを読み込む
    request.addEventListener('load', (event) => { // ロードさせ実行
        const response = event.target.responseText; // 受け取ったテキストを返す
        this.set_words_list(response); //csv_arrayの関数を実行
    });
    request.open('GET', dataPath, true); // csvのパスを指定
    request.send();
  },

  // CSVから単語リストを生成する
  set_words_list: function(data) {
      const dataString = data.split('\n'); //改行で分割
      for (let i = 1; i < dataString.length; i++) { //あるだけループ
          values = dataString[i].split(',');
          // 難易度フラグに応じて分類
          switch (values[2]){
            case "0":
              WORDS_LIST_EASY.push(values[0]);
              WORDS_LIST_HARD.push(values[0]);
              break;
            case "1":
              WORDS_LIST_EASY.push(values[0]);
              break;
            case "2":
              WORDS_LIST_HARD.push(values[0]);
              break;
          }
      }
  }

});

/*
 * メインシーン01
 */
phina.define("Scene01", {
  superClass: 'DisplayScene',

  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    
    // symbol クラス生成
    const symbol = MySymbolClass();
    this.symbol = symbol;
    
    // 背景グループ
    var bgGroup = DisplayElement().addChildTo(this);
    this.bgGroup = bgGroup;

    // 背景追加
    (2).times(function(i) {
      Sprite('game_bg').addChildTo(bgGroup)
                  .setPosition(this.gridX.center(), this.gridY.center())
                  .setSize(SCREEN_WIDTH, SCREEN_HEIGHT)
    }, this);
    
    // ワードラベルの座標
    var wordLabel_Y = 14;
    
    // 難易度表記用
    var modeLabeltext = ( SETTINGS.mode == GAME_MODE.nomal ) ? 'Mode: Nomal' : 'Mode:Hard';
    
    // ラベルとか
    this.fromJSON({
      children: {
        // 入力キーワードラベル
        wordLabel:{
          className: 'Label',
          text: '***',
          x: this.gridX.span(8),
          y: this.gridX.span(wordLabel_Y),
          fontFamily: 'Rajdhani-bold',
          fontSize: 60,
          fill:'white',
          align: 'center',          
        },
        // キーボード入力判定ラベル
        inputLabel:{
          className: 'Label',
          text: '***',
          x: this.gridX.span(8),
          y: this.gridX.span(wordLabel_Y + 1.5),
          fontFamily: 'Rajdhani-medium',
          fontSize: 40,
          fill:'white',
          align: 'center',          
        },
        // スコア
        scoreLabel: {
          className: 'Label',
          text: 'Score:',
          x: this.gridX.span(2),
          y: this.gridX.span(1),
          fontFamily: 'Rajdhani',
          align: 'left', 
          fill:'white',
        },
        // ミス数
        missLabel: {
          className: 'Label',
          text: 'Miss:',
          x: this.gridX.span(7),
          y: this.gridX.span(1),
          fontFamily: 'Rajdhani',
          align: 'left', 
          fill:'white',
        },
        // 経過時間
        timeLabel: {
          className: 'Label',
          text: 'Time:' + clear_time,
          x: this.gridX.span(12),
          y: this.gridX.span(1),
          fontFamily: 'Rajdhani',
          align: 'left', 
          fill:'white',
        },
        // 難易度
        modeLabel: {
          className: 'Label',
          text: modeLabeltext,
          x: this.gridX.span(12),
          y: this.gridX.span(2),
          fontFamily: 'Rajdhani',
          fontSize: 24,
          align: 'left', 
          fill:'white',
        },
        // 今のステージ
        stageLabel: {
          className: 'Label',
          text: 'Stage*',
          x: this.gridX.center(),
          y: this.gridX.span(2.2),
          align: 'center',
          fontSize: 32,
          fill:'white',
          fontFamily: 'Rajdhani',
        },
        // ボス名
        enemyLabel: {
          className: 'Label',
          text: 'BOSS:',
          x: this.gridX.center(),
          y: this.gridX.span(3.2),
          align: 'center', 
          fontSize: 48,
          fill:'#B429F9',
          fontFamily: 'Rajdhani-bold',
        },
        // Bombモザイク残数
        bombMosaicLabel: {
          className: 'Label',
          text: 'Bomb',
          x: this.gridX.span(1.5),
          y: this.gridX.span(20),
          align: 'left', 
          fontSize: 24,
          fill:'white',
          fontFamily: 'Rajdhani-bold',
        }, 
        // Bomb説明ラベル
        bombDescriptionLabel: {
          className: 'Label',
          text: '',
          x: this.gridX.span(9),
          y: this.gridX.span(20),
          align: 'left', 
          fontSize: 18,
          fill:'white',
          fontFamily: 'Rajdhani',
        }, 
        // プレイヤのアドレス
        addressLabel: {
          className: 'Label',
          text: 'PlayerID:' + SETTINGS.player_address,
          x: this.gridX.span(1),
          y: this.gridX.span(22.5),
          align: 'left', 
          fontSize: 18,
          fill:'white',
        }, 
        // MISS表示
        missTypeLabel: {
          className: 'Label',
          text: 'MISS!',
          x: this.gridX.center(),
          y: this.gridX.span(18),
          align: 'center', 
          fontSize: 48,
          fill:'#B429F9',
          fontFamily: 'Rajdhani-bold',
          alpha: 0,
        }, 
      },
    });
    
    // UIのレイヤ分け
    this.gameLayer = DisplayElement().addChildTo(this);
    this.enemyGroup = DisplayElement().addChildTo(this);
    this.uiLayer = DisplayElement().addChildTo(this);
    this.bombLayer = DisplayElement().addChildTo(this);
    
    //
    // UI関係ラベル
    //
    // スコア
    this.score = 0;
    this.scoreLabel.text = 'score:' + this.score;
    this.scoreLabel.addChildTo(this.uiLayer);
    // ミス数
    this.miss = 0;
    this.missLabel.text = 'miss:' + this.miss;
    this.missLabel.addChildTo(this.uiLayer);
    // ステージ表記
    this.stageLabel.text = ( SETTINGS.stage <= 2) ? ('Stage' + SETTINGS.stage) : 'Final Stage';
    this.stageLabel.addChildTo(this.uiLayer);
    
    //
    // 敵キャラ名とパラメータ設定
    //
    var boss_name = ''
    var boss_life = 10;
    switch (SETTINGS.stage) {
      case 1:
        boss_name = 'Jaguar';
        boss_life = (SETTINGS.mode == GAME_MODE.nomal ) ? 50 : 70;
        break;
      case 2:
        boss_name = 'Gimre';
        boss_life = (SETTINGS.mode == GAME_MODE.nomal ) ? 70 : 120;
        break;
      case 3:
        boss_name = 'Hatchet';
        boss_life = (SETTINGS.mode == GAME_MODE.nomal ) ? 100 : 180;
        break;
    }
    
    // ボス生成
    this.boss = Enemy(boss_name, boss_life).addChildTo(this.enemyGroup);
    this.boss.setPosition(this.gridX.center(), this.gridX.span(7));
    this.enemyLabel.text = 'BOSS ' + boss_name;
    this.enemyLabel.addChildTo(this.uiLayer);
    
    //
    // タイムゲージ設定
    //
    var limit_time = 5; // 制限時間(文字数に合わせてに変動させる)
    var self = this;
    this.time_gauge = TimeGauge({
      width: SCREEN_WIDTH * 0.8,
      height: 8,
      life: 100,
      limitTime: limit_time,
    }).addChildTo(this.uiLayer).setPosition( this.gridX.center(), this.gridX.span(wordLabel_Y  + 2.5));
    // 時間切れ時の処理
    this.time_gauge.on('empty', function(){ self.timeup() });

    //
    // プレイヤー設定
    //
    // プレイヤーのライフゲージ
    this.player_life = LifeGauge({
      width: SCREEN_WIDTH * 0.8,
      height: 20,
      life: 100,
    }).addChildTo(this.uiLayer).setPosition( this.gridX.center(), this.gridX.span(21));
    // ライフが0になったときの処理
    this.player_life.on('empty', function() {
      self.remove();  
      self.exit('gameover');
    });
    // 打ち間違いした時のペナルティ(ダメージ値)
    this.player_penalty = ( SETTINGS.mode == GAME_MODE.nomal ) ? 5 : 10;

    //
    // 単語設定
    // 単語リスト読み込み-> シャッフル
    this.shuffleList = (SETTINGS.mode == GAME_MODE.nomal) ? this.arrayShuffle(WORDS_LIST_EASY) :  this.arrayShuffle(WORDS_LIST_HARD);

    //this.wordCount = 0;   
    // 現在のワード
    this.currentWord = ''
    this.currentWordLength = 0;  // 単語の長さ
    this.charCount = 0;   // 打ち込んだ文字数(正解数)
    
    // ボムモザイクをセット
    var bomb_max = SETTINGS.bomb_mosaic;
    this.bombMosaicLabel.text = ( SETTINGS.bomb_mosaic == 0)
                                ? 'Bomb :0'
                                : 'Bomb : ('+(SETTINGS.bomb_mosaic - SETTINGS.bomb_use_count)+'/'+ SETTINGS.bomb_mosaic +')';
    this.bombDescriptionLabel.text = (SETTINGS.bomb_mosaic == 0) ? '' : 'Tap Bomb icon or hit the spacebar!';
    var bomb_zan = SETTINGS.bomb_mosaic - SETTINGS.bomb_use_count;
    if( bomb_zan > 3) bomb_zan = 3;
    if ( bomb_zan > 0){
      (bomb_zan).times(function(i){
        var sprite = Sprite('Bomb',50,40).addChildTo(self.bombLayer);
        var half = sprite.width / 2;
        // ランダムな位置
        sprite.x = self.gridX.span(5.5+(i*1.2));
        sprite.y = self.gridX.span(20)
        // タッチを有効にする
        sprite.setInteractive(true);
        // タッチイベント登録
        sprite.onpointstart = function() {
          // ボム発動イベント
          self.onBombPush();
          
        };
      });
    }

    
    // ステージクリア処理の待機用
    this.isStageClear = false;  // ステージクリアしたか？
    this.stayCount = 3000;      // ステージクリア時の待機時間
    
    // 単語生成してゲーム開始！！
    this.createWord();
    
    // BGMスタート
    SoundManager.setVolumeMusic(0.1);
    SoundManager.playMusic('bgm');
  },
  
  // 文字生成 
  createWord: function() {
    // リストが空またはすでにステージクリア済みなら何もしない
    if(this.shuffleList.length == 0 || this.isStageClear == true){
      return
    }
    // キーワードを1つ取り出してラベル表示(ここは空白あり表示)
    var original_word = this.shuffleList.pop();
    //var original_word = 'AccountOperationRestrictionTransaction';

    // 空白削除して文字列長取得
    var input_word = original_word.replace(/\s+/g, '');
    var words_array = input_word.toArray()
    var len = words_array.length;
    
    // 保持する情報を初期化
    this.currentWord =　input_word;
    this.inputLabel.text = input_word.toLowerCase();  // 全て小文字に変換
    this.currentWordLength = len;
    this.charCount = 0;
    
    // 文字数にあわせてラベルのフォントサイズ調整
    if( len >= 30 ){
      this.wordLabel.fontSize = 32;
      this.inputLabel.fontSize =32;
    }else{
      this.wordLabel.fontSize = ( len >= 20 ) ? 42 : 60;
      this.inputLabel.fontSize = 40;
    }
    this.wordLabel.text = original_word; 

    // タイマをリセット(文字列長にあわせて残り時間調整)
    // 難易度ノーマル -> 3文字/S
    // 難易度ハード -> 5文字/S
    var param = (SETTINGS.mode == GAME_MODE.nomal) ? 2 : 3.5;
    var time_val = Math.ceil(this.currentWordLength / param);
    this.time_gauge.recover(time_val);
  },
  
  // キーボード入力時処理
  onkeydown: function(e) {
    
    // 次の単語がなかったら何もしない
    if ( this.charCount >= this.currentWordLength){
      return
    }
    
    // キー入力取得
    var ch = String.fromCharCode(e.keyCode)
    
    // 次に次に入力次に入力すべき文字と合っているか？
    var w = this.currentWord.charAt(this.charCount).toUpperCase();
    var result = ( w == ch);

    // キー入力正解時処理
    if( result ){
      this.missTypeLabel.alpha = 0;
          
      // 正解時の効果音を鳴らす
      SoundManager.play("ok");
      // 正解文字数を加算
      this.charCount++;
      // 入力状態表示ラベルを1文字削除
      this.inputLabel.text = this.inputLabel.text.slice(1);
      // スコア更新
      this.score += 1;
      this.scoreLabel.text = 'score:' + this.score;  
      // 全文字消えた？
      if ( this.charCount == this.currentWordLength){
        // 初期化
        this.charCount = 0;
        this.inputLabel.text ='';
        // 次の単語へ
        this.changeNextWord( this.currentWordLength );
      }
      return;
    }
    
    // スペースキー入力時 -> ボム発動！
    if (e.keyCode === 32) {
      
      // ボム発動イベント
      this.onBombPush();
      return;
      
    }

    // それ以外のパターンはミスタイプ 
    // ラベル表示
    this.missTypeLabel.alpha = 100;
    
    // 弾を発射
    SoundManager.play('ng');
    this.createBullet( this.player_penalty );
    //this.player_damage(this.player_penalty);
    
    // ミスラベル更新
    this.miss++;
    this.missLabel.text = 'miss:' + this.miss;
    
  },
  
  // ボム発動時処理
  onBombPush: function(){

    // 条件満たしてなければ何もしない
    if( SETTINGS.bomb_mosaic < 1 ) return;
    if( SETTINGS.bomb_use_count >= SETTINGS.bomb_mosaic ) return;

    // Todo: ボム発動効果音やエフェクト
    SoundManager.play('bomb_sound');

    // ボム使用数を加算しラベル更新
    SETTINGS.bomb_use_count++;
    this.bombMosaicLabel.text = 'Bomb : ('+(SETTINGS.bomb_mosaic - SETTINGS.bomb_use_count)+'/'+ SETTINGS.bomb_mosaic +')';
    
    // ボムiconをひとつ削除
    this.bombLayer.children.last.remove();

    // 敵の残りライフの1/3のダメージ！
    var damage = Math.round(this.boss.life.value/3);
    this.boss.damage(damage);
    
    // タイムゲージを復活
    this.time_gauge.pause();
    this.time_gauge.recover();
    this.time_gauge.run();
    
    // ボムモザイクを1つ回収
    this.symbol.mosaicRevokable( SETTINGS.player_address );

  },
  // 更新処理
  update: function(app) {
    
    // クリアタイム計測
    clear_time += app.deltaTime;
    this.timeLabel.text = 'Time:' + Math.floor(clear_time / 1000) + 'sec'; 
    
    // タイムゲージ減少処理
    if( this.time_gauge.running ){
      this.time_gauge.value -= this.time_gauge.rate;
    };
    
    if ( !this.isStageClear ) return;
    // ステージクリア状態 -> 少し待って次画面次画面へ
    this.stayCount -= app.deltaTime;  // ちょっと待つ
    if( this.stayCount < 0){
      if( SETTINGS.stage >= 3){
        // 最終ステージ(3面)までクリアしてたらリザルト画面へ
        this.exit('result');
      }else{
        // それ以外の場合はカウント画面へ
        SETTINGS.stage += 1;
        this.exit('count');
      }
    }
  
  },
  
  // プレイヤーへのダメージ処理
  player_damage : function(value){
    //  音を鳴らす
    SoundManager.play('damage');
    this.player_life.value -= value;
  },
  
  // 弾丸作成&ダメージ処理
  createBullet: function( damage ) {
    var bullet_type = '';
    switch(SETTINGS.stage){
      case 1:
        bullet_type = 'shuriken';
        break;
      case 2:
        bullet_type = 'beam';
        break;
      case 3:
        bullet_type = 'ono';
        break
    }

    var bul = Bullet(bullet_type).addChildTo(this);
    //bul.x = this.gridX.center();
    //bul.y = 500;
    
    // 敵の攻撃力
    bul.attack = damage;

    // 弾をくらった時のダメージ処理
    bul.onattack = function() {
      this.player_damage( bul.attack );
    }.bind(this);
    
    // 弾をランダムな起動で移動させる
    var path = this.createBulletPath();
    this.moveAlongPath( bul, path );

    return bul;
  },
  
  // 弾丸の軌跡を生成
  createBulletPath: function(){
    
    var gx = this.gridX;
    var gy = this.gridY;
    var vec = Vector2;
    
    // 頂点データ
    var verts =[]
    var patern = Math.floor( Math.random() * 5 ) ;
    
    switch( patern ){
      case 0:
        verts = [vec(gx.span(8), gy.center()),
                 vec(gx.span(8), gy.center(7))];
        break;
      case 1:
        verts = [vec(gx.span(8), gy.center()),
                 vec(gx.span(4), gy.center(7))];
        break;
      case 2:
        verts = [vec(gx.span(8), gy.center()),
                 vec(gx.span(12), gy.center(7))];
        break;
      case 3:
        verts = [vec(gx.span(8), gy.center()),
                 vec(gx.span(2), gy.center(7))];
        break;
      case 4:
        verts = [vec(gx.span(8), gy.center()),
                 vec(gx.span(14), gy.center(7))];
      break;
    }

    return verts;
  },
  
 // ターゲットを与えられたパスに沿って移動させる
  moveAlongPath: function(target, path) {
    
    // 最初の頂点へ移動
    target.position = path.first;
    // 頂点群をループ
    path.each(function(vert, i) {
      if (i > 0) {
        // tweenをスタック
        target.tweener._add({
          type: 'tween',
          mode: 'to',
          props: {x: vert.x, y: vert.y},
          duration: 700,
        });
      }
    });
  },
 
  // 時間切れ処理
  timeup: function(){
  
    SoundManager.play('timeout');

    // 一旦タイマカウント停止
    this.time_gauge.pause();
    // 弾を発射
    this.createBullet( this.boss.attack );
    // タイマを補充
    this.time_gauge.recover();
    // カウント再開
    this.time_gauge.run();
  },
 
  // 1単語クリア時処理
  changeNextWord: function( damage ){
    
    // 1単語クリア効果音
    SoundManager.play('word_clear');
        
    // ボスにダメージ
    this.boss.damage( damage );
    SoundManager.play('damage');

    if( this.boss.isDown() ){
      // ボス撃破でクリアステージクリア処理
      this.onStageClear();
    }else{
      // 未撃破なら次の単語に
      this.createWord();
    }
    
  },
 
  // ステージクリア時処理
  onStageClear: function(){
    
    // ステージクリアフラグ更新&タイマーゲージ停止
    this.isStageClear = true;
    this.time_gauge.pause();
    
    // Todo:ステージクリアの音を鳴らす
    SoundManager.play('ko');
    
    // ステージクリアのラベル表示
    var clearLabel = Label({
    text:'Clear!',
    fontSize:120,
    fontFamily: 'Rajdhani-bold',
    fill:'#5591F5',
    }).addChildTo(this).setPosition(this.gridX.center(),this.gridY.span(6))
    .tweener.fadeOut(1000).fadeIn(500).setLoop(true).play();
    
    // スコア保持
    total_score =  this.score;
    total_miss = this.miss;
    
  },
 
  // 配列のランダムソート
  arrayShuffle: function(array) {
    for(var i = (array.length - 1); 0 < i; i--){
  
      // 0〜(i+1)の範囲で値を取得
      var r = Math.floor(Math.random() * (i + 1));
  
      // 要素の並び替えを実行
      var tmp = array[i];
      array[i] = array[r];
      array[r] = tmp;
    }
    return array;
  },

});

/*
 * 弾クラス
 */
phina.define("Bullet", {
  // 継承
  superClass: 'Sprite',
  // コンストラクタ
  init: function(name) {
    // 親クラス初期化
    this.superInit(name, 100, 100);
    var s1 = this.width * 0.8;
    var s2 = this.width / 10;
    var half = this.width / 2;
    this.attack = 50;
  },
  update: function() {
    
    //this.y += 15;
    
    // 自身を回転
    this.rotation += 15;
    
    // 当たり判定
    if (this.y > 860) {
      this.flare('attack');
      this.remove();
    }
  },
  disappear: function() {
    this.enable = false;
    this.tweener
      .to({
        scaleX: 2,
        scaleY: 2,
        alpha: 0,
      }, 250)
      .call(function() {
        this.target.remove();
      });
  }
});

/*
 * 敵クラス
 */
phina.define("Enemy", {
  // 継承
  superClass: 'Sprite',
  // コンストラクタ
  init: function(name, life_val) {
    // 親クラス初期化
    this.superInit(name);
    // ライフゲージ
    this.life = LifeGauge({
      width: this.width * 0.8,
      height: this.height / 20,
      life: life_val,
    }).addChildTo(this);
    // ライフゲージの位置
    this.life.y = this.height / 2 - this.life.height * 2;
    var self = this;
    // ライフが無くなった時の処理
    this.life.on('empty', function() {
      self.remove();  
    });
    // 攻撃力
    this.attack = (SETTINGS.mode == GAME_MODE.nomal ) ? 20 : 30;

    var s1 = this.width * 0.8;
    var s2 = this.width / 10;
    var half = this.width / 2;

  },
  // ダメージ処理
  damage: function(value) {
    this.life.value -= value;
    // 点滅させる
    this.tweener.fadeOut(100).fadeIn(100).fadeOut(100).fadeIn(100).play();
  },
  // 倒したか？
  isDown: function(){
    return this.life.isEmpty();
  },
});

/*
 * ライフゲージクラス
 */
phina.define("LifeGauge", {
  // 継承
  superClass: 'Gauge',
  // コンストラクタ
  init: function(param) {
    // 親クラス初期化
    this.superInit({
      width: param.width,
      height: param.height,
      fill: 'red',
      stroke: 'silver',
      gaugeColor: 'limegreen',
      maxValue: param.life,
      value: param.life,
    });
    // 値変化アニメーションの時間
    this.animationTime = 500;
  },
});


/*
 * タイムゲージクラス
 */
phina.define("TimeGauge", {
  // 継承
  superClass: 'Gauge',
  // コンストラクタ
  init: function(param) {
    // 親クラス初期化
    this.superInit({
      width: param.width,
      height: param.height,
      fill: 'white',
      stroke: 'silver',
      gaugeColor: '#6A5ACD',
      maxValue: param.life,
      value: param.life,
    });
    // 値変化アニメーションの時間
    this.animationTime = 50;
    // 制限時間
    this.limitTime = param.limitTime;
    // タイマ有効化フラグ
    this.running = true;
    // 1フレームあたりの変化量
    this.rate = this.value / ( this.limitTime * 30);
  },
  run: function(){
    this.running = true;
  },
  pause: function(){
    this.running = false;
  },
  recover: function( val=0 ){
    if( val > 0){
      this.limitTime = val;
      this.rate = this.maxValue / ( this.limitTime * 30);
    }
    this.value = this.maxValue;
  }
});

/*
 * カウント画面
 * 
 */
phina.define('CountScene', {
  superClass: 'phina.display.DisplayScene',
  /**
   * @constructor
   */
  init: function(options) {
    this.superInit(options);

    options = (options || {}).$safe(phina.game.CountScene.defaults);

    // グループ
    var bgGroup = DisplayElement().addChildTo(this);
    this.bgGroup = bgGroup;


    this.backgroundColor = options.backgroundColor;
    
    // 背景追加
    (2).times(function(i) {
      Sprite('title_bg').addChildTo(bgGroup)
                  .setPosition(this.gridX.center(), this.gridY.center())
                  .setSize(SCREEN_WIDTH, SCREEN_HEIGHT)
    }, this);

    this.fromJSON({
      children: {
        msglabel: {
          className: 'Label',
          arguments: {
            fill: 'white',
            fontSize: 48,
            stroke: false,
            text:'Stage ' + ( SETTINGS.stage ),
          },
          x: this.gridX.center(),
          y: this.gridY.span(4),
        },
        label: {
          className: 'Label',
          arguments: {
            fill: options.fontColor,
            fontSize: options.fontSize,
            stroke: false,
          },
          x: this.gridX.center(),
          y: this.gridY.center(),
        },
      }
    });
    
    // 最終ステージならラベルを変更
    if(SETTINGS.stage == 3){
      this.msglabel.text = 'Final Stage!';
    }

    if (options.count instanceof Array) {
      this.countList = options.count.reverse();
    }
    else {
      this.countList = Array.range(1, options.count+1);
    }
    this.counter = this.countList.length;
    this.exitType = options.exitType;

    this._updateCount();
  },

  _updateCount: function() {
    var endFlag = this.counter <= 0;
    var index = --this.counter;

    this.label.text = this.countList[index];

    this.label.scale.set(1, 1);
    this.label.tweener
      .clear()
      .to({
        scaleX: 1,
        scaleY: 1,
        alpha: 1,
      }, 250)
      .wait(500)
      .to({
        scaleX: 1.5,
        scaleY: 1.5,
        alpha: 0.0
      }, 250)
      .call(function() {
        if (this.counter <= 0) {
          this.flare('finish');
          if (this.exitType === 'auto') {
            this.app.popScene();
          }
        }
        else {
          this._updateCount();
        }
      }, this);
  },


  _static: {
    defaults: {
      count: 3,

      width: 640,
      height: 960,

      fontColor: 'white',
      fontSize: 164,
      backgroundColor: 'rgba(50, 50, 50, 1)',

      exitType: 'auto',
    },
  },

});


/*
 * リザルト画面
 */
phina.define('ResultScene', {
    superClass: 'DisplayScene',
    /**
     * @constructor
     */
    init: function(params) {
      this.superInit(params);

      params = ({}).$safe(params, phina.game.ResultScene.defaults);

      var message = params.message.format(params);

      this.backgroundColor = params.backgroundColor;
      
      // 背景グループ
      var bgGroup = DisplayElement().addChildTo(this);
      this.bgGroup = bgGroup;
  
      // 背景追加
      (2).times(function(i) {
        Sprite('result_bg').addChildTo(bgGroup)
                    .setPosition(this.gridX.center(), this.gridY.center())
                    .setSize(SCREEN_WIDTH, SCREEN_HEIGHT)
      }, this);
                  
      
      // プレイヤーへのメッセージ
      var modeLabelText = '';
      var messageText = '';
      if( SETTINGS.mode == GAME_MODE.nomal){
        modeLabelText = 'Nomal Mode';
        messageText =  'Thanks for playing!\n' + 'Try hard mode next time!'
      }else{
        modeLabelText = 'Hard Mode';
        messageText = 'Congratulations!\nYou\'re a typing master!';
      }
      
      // Symbolクラス生成
      const symbol = MySymbolClass();
      this.symbol = symbol;
      
      
      // クリア報酬トランザクションを発行！
      if( SETTINGS.player_address != ''){
        var today = new Date(); 
        var amount = 10;
        switch( SETTINGS.mode ){
          case GAME_MODE.nomal:
            amount = ( total_miss == 0 ) ? 30 : 10;
            break;
          case GAME_MODE.hard:
            amount= ( total_miss == 0 ) ? 100 : 30;
        }
        const msg_json = {
          'msg':'Symbol Typing Game Clear Rewards!Thanks for playing!',
          'date': '' + today.getFullYear() + '/' +  (today.getMonth()+1) + '/' + today.getDate(),
          'time': '' + Math.floor(clear_time / 1000),
          'score': '' + total_score,
          'miss': '' + total_miss
        }
        this.symbol.sendXym( SETTINGS.player_address, amount, JSON.stringify(msg_json));
      }
      
      // ラベルとかセット
      this.fromJSON({
        children: {
          titleLabel: {
            className: 'phina.display.Label',
            arguments: {
              text: 'GAME CLEAR!',
              fill: '#F4A900',
              stroke: null,
              fontSize: 100,
              fontFamily:'Rajdhani-bold',
            },
            x: this.gridX.span(8),
            y: this.gridY.span(3.5),
          },
          gameModeLabel: {
            className: 'phina.display.Label',
            arguments: {
              text: modeLabelText,
              fill: params.fontColor,
              stroke: null,
              fontSize: 48,
              fontFamily:'Rajdhani',
            },
            x: this.gridX.span(8),
            y: this.gridY.span(5),
          },
          timeLabel: {
            className: 'phina.display.Label',
            arguments: {
              text: 'Time  ' + Math.floor(clear_time / 1000) + ' sec',
              fill: params.fontColor,
              stroke: null,
              fontSize: 38,
              fontFamily:'Rajdhani',        
              align: 'left', 
            },
            x: this.gridX.span(5),
            y: this.gridY.span(6),
          },
          scoreLabel: {
            className: 'phina.display.Label',
            arguments: {
              text: 'Score ' + total_score,
              fill: params.fontColor,
              stroke: null,
              fontSize: 38,
              fontFamily:'Rajdhani',
              align: 'left', 
            },
            x: this.gridX.span(5),
            y: this.gridY.span(7),
          },
          missLabel: {
            className: 'phina.display.Label',
            arguments: {
              text: 'Miss   ' + total_miss,
              fill: params.fontColor,
              stroke: null,
              fontSize: 38,
              fontFamily:'Rajdhani',
              align: 'left', 
            },
            x: this.gridX.span(5),
            y: this.gridY.span(8),
          },

          messageLabel: {
            className: 'phina.display.Label',
            arguments: {
              text: messageText,
              fill: params.fontColor,
              stroke: null,
              fontSize: 32,
              fontFamily:'Rajdhani',
            },
            x: this.gridX.center(),
            y: this.gridY.span(9.5),
          },

          shareButton: {
            className: 'phina.ui.Button',
            arguments: [{
              text: 'Share',
              width: 400,
              height: 60,
              fontColor: params.fontColor,
              fontSize: 32,
              cornerRadius: 8,
              fill: 'rgba(240, 240, 240, 0.5)',
              // stroke: '#aaa',
              // strokeWidth: 2,
            }],
            x: this.gridX.center(),
            y: this.gridY.span(12),
          },
          shareButton: {
            className: 'phina.ui.Button',
            arguments: [{
              text: 'Share',
              width: 400,
              height: 60,
              fontColor: params.fontColor,
              fontSize: 32,
              cornerRadius: 8,
              fill: 'rgba(240, 240, 240, 0.5)',
              // stroke: '#aaa',
              // strokeWidth: 2,
            }],
            x: this.gridX.center(),
            y: this.gridY.span(11.5),
          },
          playButton: {
            className: 'phina.ui.Button',
            arguments: [{
              text: 'Play again',
              width: 400,
              height: 60,
              fontColor: params.fontColor,
              fontSize: 32,
              cornerRadius: 8,
              fill: 'rgba(240, 240, 240, 0.5)',
              // stroke: '#aaa',
              // strokeWidth: 2,
            }],
            x: this.gridX.center(),
            y: this.gridY.span(13),
            
            interactive: true,
            onpush: function() {
              // リプレイフラグを建てる
              SETTINGS.isReplay = true;
              this.exit();
            }.bind(this),
          },
          topButton: {
            className: 'phina.ui.Button',
            arguments: [{
              text: 'Top',
              width: 400,
              height: 60,
              fontColor: params.fontColor,
              fontSize: 32,
              cornerRadius: 8,
              fill: 'rgba(240, 240, 240, 0.5)',
              // stroke: '#aaa',
              // strokeWidth: 2,
            }],
            x: this.gridX.center(),
            y: this.gridY.span(14.5),
            
            interactive: true,
            onpush: function() {
              SETTINGS.isReplay = false;
              this.exit();
            }.bind(this),
          },
        }
      });
      
      // 点滅処理
      this.titleLabel.tweener.fadeOut(1000).fadeIn(500).setLoop(true).play();

      // シェアボタン押下時
      var modetext = (SETTINGS.mode == GAME_MODE.nomal)? 'Nomal' : 'Hard ( Congratulations! )';
      this.shareButton.onclick = function() {
        var text = 'Symbol Typing Quest Clear!\n'
                    + 'Mode : ' + modetext
                    + '\nTime : ' + Math.floor(clear_time / 1000) + 'second | Score : ' + total_score + ' | Miss : ' + total_miss;
        var url = phina.social.Twitter.createURL({
          text: text,
          hashtags: 'Symbol,XYM,Blockchain',
          url: 'http://runstant.com/kurikou02/projects/47b683ae',
        });
        window.open(url, 'share window', 'width=480, height=320');
      };
      
      // デモモードなら、エクスプローラーに誘導する
      if( SETTINGS.isDemo ){
          Swal.fire({
            title: 'Thanks for playing!',
            text: 'A clear reward token has been sent to Symbol wallet for the trial, please check Symbol blockchain explorer!',
            footer: '<a href="https://testnet.symbol.fyi/accounts/TBS6OAC3ZM66ZVSXNURUQGOYT6AVA4MFXUVS3EI" target="_blank" rel="noopener noreferrer">Symbol Blockchain Explorer(TEST NET)</a>',
          });
      }
      
      // ファンファーレ
      SoundManager.play('game_clear');
    },
    
    // デフォルトパラメータ定義    
    _static: {
      defaults: {
        url: phina.global.location && phina.global.location.href,

        width: 640,
        height: 960,

        fontColor: 'white',
        backgroundColor: 'hsl(200, 80%, 64%)',
        backgroundImage: '',
      },
    },

  });
  
/*
 * ゲームオーバー画面
 */
phina.define('GameOverScene', {
    superClass: 'DisplayScene',
  /**
   * @constructor
   */
  init: function() {
    this.superInit();
    
    // symbol クラス生成
    var symbol = MySymbolClass();
    this.symbol = symbol;
    

    // グループ
    var bgGroup = DisplayElement().addChildTo(this);
      // 参照用
    this.bgGroup = bgGroup;
    // 背景追加
    (2).times(function(i) {
      Sprite('gameover_bg').addChildTo(bgGroup)
                  .setPosition(this.gridX.center(), this.gridY.center())
                  .setSize(SCREEN_WIDTH, SCREEN_HEIGHT)
    }, this);

    // タイトル
    var titleLabel = Label({
      text: 'Game Over!',
      fontSize: 100,
      fontFamily: 'Rajdhani-bold',
      fill:'white',
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(4));
    titleLabel.alpha = 0;
    titleLabel.tweener.fadeIn(3500).play();
    
    // 説明文
    Label({
      text: 'Was it too hard?\nYou can get some useful items for the game.\nPress the \"Get Bomb Mosaic\" button below.',
      fontSize: 32,
      fontFamily: 'Rajdhani-bold',
      fill:'white',
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(8));

    // ボタンボタン設置
    var GetBombButton = Button({
      width: 400,             // 横サイズ
      height:60,            // 縦サイズ
      text: "Get Bomb Mosaic", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: '#170a29',    // ボタン色
      stroke: '#977bff',     // 枠色
      strokeWidth: 5,     // 枠太さ
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(12));
    this.GetBombButton = GetBombButton;
    
    // ボタンボタン設置
    var ReturnTopButton = Button({
      width: 400,             // 横サイズ
      height:60,            // 縦サイズ
      text: "TOP", // 表示文字
      fontSize: 24,       // 文字サイズ
      fontColor: 'white', // 文字色
      cornerRadius: 10,   // 角丸み
      fill: '#170a29',    // ボタン色
      stroke: '#977bff',     // 枠色
      strokeWidth: 5,     // 枠太さ
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(14));
    this.ReturnTopButton = ReturnTopButton;
    
      
      
    // 画面タッチ時
    this.on('pointend', function() {
      // 次のシーン(ゲームスタート)へ
      //this.exit('title');
    });
    
    
    // ++++++++++++++++++++++++++++
    // イベント処理
    // ++++++++++++++++++++++++++++
    
    // this参照を保持
    var self = this;
    
    // BOMbモザイク発行
    GetBombButton.onclick = function(){
      
      // デモモードの場合はごめんなさい
      if( SETTINGS.isDemo ){
         Swal.fire('Sorry!This feature is not available in trial mode!');
         return;  
      }
      
       if( SETTINGS.player_address == ''){
         Swal.fire('Error!Failed to get address.');
         return;
       }
       
      // ボムモザイクをすでに3以上持ってたら発行しない
      var amount = 3 - ( SETTINGS.bomb_mosaic - SETTINGS.bomb_use_count);
      if( amount < 1){
        Swal.fire('Sorry.You already have three bombs, so I can\'t grant you any more.');
        return;
      }

      // Bombモザイクを発行！
      console.log('ボムモザイク発行！：' + amount );
      var msg = 'These are optional items for the Symbol Typing game.\nIt will be automatically collected when consumed in the game.';
      symbol.sendBombMosaic( SETTINGS.player_address, amount, msg);
      Swal.fire('\"Bomb Mosaic\" has been issued.\nPlease access the game again after the transaction is approved.');
      this.remove();
    }

    // トップに戻る
    ReturnTopButton.onclick = function(){
      SETTINGS.isReplay = true;
      self.exit('title');
    }
    
    SoundManager.play('game_over');
  },
  });

/*
 * メイン処理
 */
phina.main(function() {

  let dom = document.createElement('div');
  let resize = () => {
      let e = app.domElement;
      let c = app.canvas;
      let s = e.style;
      let ds = dom.style;
      let rect = e.getBoundingClientRect();
      ds.width = 0;
      ds.height = 0;
      ds.position = 'absolute';
      ds.left = rect.left + 'px';
      ds.top = rect.top + 'px';
      let rate = parseInt(s.width) / c.width;
      ds.transform = 'scale(' + rate + ',' + rate + ')';
  };
  
  window.addEventListener('resize', resize);
  Scene.prototype.baseDom = dom;
  
  // アプリケーションを生成
  var app = GameApp({
    // SplashScene から開始
    startLabel: 'title',
    //startLabel: 'scene01',
    // アセット読み込み
    assets: ASSETS,
    // シーン読みこみ
    scenes:[
      {
        className: 'TitleScene',
        label: 'title',
        nextLabel: 'count',        
      },
      {
        className: 'CountScene',
        label: 'count',
        nextLabel: 'scene01',
      },
      {
        className: 'Scene01',
        label: 'scene01',
        nextLabel: 'result',
      },
      {
        className: 'GameOverScene',
        label: 'gameover',
        nextLabel: 'count',
      },
      {
        className: 'ResultScene',
        label: 'result',
        nextLabel: 'title',
      },
    ]
  });
  // fps表示
  //app.enableStats();
  app.baseDom = dom;
  // 実行
  app.run();
  
  resize();
  app.domElement.parentNode.insertBefore(dom, app.domElement.nextSibling);
});</script>
  </body>
</html>

